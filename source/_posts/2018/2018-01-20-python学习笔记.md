---
layout: posts
title: python学习笔记
categories: python学习笔记
tags: 
    - python
---

<div id="MDcategory"></div>
## 基础
### 注释
注释 是任何存在于 # 号右侧的文字，其主要用作写给程序读者看的笔记。
举个例子：
```
print('hello world') #注意到 print 是一个函数
```
### 输入与输出
#### 输出
用`print()`在括号中加上字符串，就可以向屏幕上输出指定的文字。比如输出'hello, world'，用代码实现如下：
```
>>> print('hello, world')
```
`print()`函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出：
```
>>> print('The quick brown fox', 'jumps over', 'the lazy dog')
The quick brown fox jumps over the lazy dog
```
`print()`会依次打印每个字符串，遇到逗号“,”会输出一个空格。
### 输入
Python提供了一个`input()`，可以让用户输入字符串，并存放到一个变量里,还可以让你显示一个字符串来提示用户。如：
```
name = input('please enter your name: ')
print('hello,', name)
```
input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数。Python提供了int()函数来完成这件事情：
```
s = input('birth: ')
birth = int(s)
if birth < 2000:
    print('00前')
else:
    print('00后')
```
### 数据类型
#### 整数
Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。

计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。

#### 浮点数
浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。
整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。

#### 字符串
字符串是以单引号'或双引号"括起来的任意文本，比如'abc'，"xyz"等等。请注意，''或""本身只是一种表示方式，不是字符串的一部分，因此，字符串'abc'只有a，b，c这3个字符。如果'本身也是一个字符，那就可以用""括起来，比如"I'm OK"包含的字符是I，'，m，空格，O，K这6个字符。
**如果字符串内部既包含'又包含"怎么办？可以用转义字符\来标识，也可以在*三引号*之间自由地使用单引号与双引号。**
如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r''表示''内部的字符串默认不转义。
#### 布尔值
一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：
```
>>> True
True
>>> False
False
>>> 3 > 2
True
>>> 3 > 5
False
```
布尔值可以用and、or和not运算。
```
>>> 5 > 3 and 3 > 1
True
```
#### 空值
空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。
### 变量
在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，
```
a = 123 # a是整数
print(a)
a = 'ABC' # a变为字符串
print(a)
```
这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。
### 运算符与表达式
下面是可用运算符的速览：

1. **\+（加)**   
两个对象相加。
3+5 则输出 8 。 'a' + 'b' 则输出 'ab' 。
2. **\- （减)**     
从一个数中减去另一个数，如果第一个操作数不存在，则假定为零。
-5.2 将输出一个负数， 50 - 24 输出 26 。
3. **\* （乘）**     
给出两个数的乘积，或返回字符串重复指定次数后的结果。
  'la' * 3 输出 'lalala' 。
4. **\** （乘方）**     
返回 x 的 y 次方。
3 ** 4 输出 81 （即 3 * 3 * 3 * 3 ）。
5. **/ （除）**   
x 除以 y
13 / 3 输出 4.333333333333333 。
6. **// （整除）**
x 除以 y 并对结果向下取整至最接近的整数。
13 // 3 输出 4 。
-13 // 3 输出 -5 。
7. **% （取模）**
返回除法运算后的余数。
13 % 3 输出 1 。 -25.5 % 2.25 输出 1.5 。
8. **<< （左移）**
将数字的位向左移动指定的位数。（每个数字在内存中以二进制数表示，即 0 和1）
2 << 2 输出 8 。 2 用二进制数表示为 10 。
向左移 2 位会得到 1000 这一结果，表示十进制中的 8 。
9. **>> （右移）**
将数字的位向右移动指定的位数。
11 >> 1 输出 5 。
11 在二进制中表示为 1011 ，右移一位后输出 101 这一结果，表示十进制中的
5 。
10. **& （按位与）**
对数字进行按位与操作。
5 & 3 输出 1 。
11. **| （按位或）**
对数字进行按位或操作。
5 | 3 输出 7 。
12. **^ （按位异或）**
对数字进行按位异或操作。
5 ^ 3 输出 6 。
13. **~ （按位取反）**
x 的按位取反结果为 -(x+1)。
~5 输出 -6 。
### 格式化
在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：
```
>>> 'Hello, %s' % 'world'
'Hello, world'
>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)
'Hi, Michael, you have $1000000.'
```
在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。     
如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串    
另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，
```
>>> 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)
'Hello, 小明, 成绩提升了 17.1%'
```
### list
Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。
比如，列出班里所有同学的名字，就可以用一个list表示：
```
>>> classmates = ['Michael', 'Bob', 'Tracy']
>>> classmates
['Michael', 'Bob', 'Tracy']
```
变量classmates就是一个list。用len()函数可以获得list元素的个数   
用索引来访问list中每一个位置的元素，记得索引是从0开始的：   
```
>>> classmates[0]
'Michael'
>>> classmates[1]
'Bob'
>>> classmates[2]
'Tracy'
>>> classmates[3]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
```
如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素  
list是一个可变的有序表，所以，可以往list中追加元素到末尾：
```
>>> classmates.append('Adam')
>>> classmates
['Michael', 'Bob', 'Tracy', 'Adam']
```
也可以把元素插入到指定的位置，比如索引号为1的位置：
```
>>> classmates.insert(1, 'Jack')
>>> classmates
['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']
```
要删除list末尾的元素，用pop()方法
```
>>> classmates.pop()
'Adam'
>>> classmates
['Michael', 'Jack', 'Bob', 'Tracy']
```
要删除指定位置的元素，用pop(i)方法，其中i是索引位置：
```
>>> classmates.pop(1)
'Jack'
>>> classmates
['Michael', 'Bob', 'Tracy']
```
要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：
```
>>> classmates[1] = 'Sarah'
>>> classmates
['Michael', 'Sarah', 'Tracy']
```
### tuple
另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：
```
>>> classmates = ('Michael', 'Bob', 'Tracy')
```
现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。   
tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来   
只有1个元素的tuple定义时必须加一个逗号
```
>>> t = (1,)
>>> t
(1,)
```
最后来看一个“可变的”tuple：
```
>>> t = ('a', 'b', ['A', 'B'])
>>> t[2][0] = 'X'
>>> t[2][1] = 'Y'
>>> t
('a', 'b', ['X', 'Y'])
```
### 条件判断
```
age = 3
if age >= 18:
    print('adult')
elif age >= 6:
    print('teenager')
else:
    print('kid')
```
### 循环
#### for...in循环
```
names = ['Michael', 'Bob', 'Tracy']
for name in names:
    print(name)
```
执行这段代码，会依次打印names的每一个元素：
```
Michael
Bob
Tracy
```
range(101)就可以生成0-100的整数序列，计算如下
```
sum = 0
for x in range(101):
    sum = sum + x
print(sum)
```
#### while循环
只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：   
```
sum = 0
n = 99
while n > 0:
    sum = sum + n
    n = n - 2
print(sum)
```
在循环中，break语句可以提前退出循环。   
在循环过程中，也可以通过continue语句，跳过当前的这次循环(continue后面语句不执行)，直接开始下一次循环。
### dict
Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。  
```
>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
>>> d['Michael']
95
```
把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：
```
>>> d['Adam'] = 67
>>> d['Adam']
67
```
由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉,如果key不存在，dict就会报错.   
要删除一个key，用pop(key)方法，对应的value也会从dict中删除：
```
>>> d.pop('Bob')
75
>>> d
{'Michael': 95, 'Tracy': 85}
```
和list比较，dict有以下几个特点：

1.查找和插入的速度极快，不会随着key的增加而变慢；    
2.需要占用大量的内存，内存浪费多。    
3.dict内部存放的顺序和key放入的顺序是没有关系的   
而list相反：     

1.查找和插入的时间随着元素的增加而增加；    
2.占用空间小，浪费内存很少。      
### set
set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。
要创建一个set，需要提供一个list作为输入集合：
```
>>> s = set([1, 2, 3])
>>> s
{1, 2, 3}
```  
注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。   
重复元素在set中自动被过滤。    
通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果:
```
>>> s.add(4)
>>> s
{1, 2, 3, 4}
>>> s.add(4)
>>> s
{1, 2, 3, 4}
```
通过remove(key)方法可以删除元素：
```
>>> s.remove(4)
>>> s
{1, 2, 3}
```
## 函数
### 定义函数
```
def my_abs(x):
    if x >= 0:
        return x
    else:
        return -x
```
### 返回多个值
```
import math

def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny
```
```
>>> x, y = move(100, 100, 60, math.pi / 6)
>>> print(x, y)
151.96152422706632 70.0
```
其实返回的是一个tuple
```
>>> r = move(100, 100, 60, math.pi / 6)
>>> print(r)
(151.96152422706632, 70.0)
```
### 函数的参数
#### 默认参数
```
def power(x, n=2):
    s = 1
    while n > 0:
        n = n - 1
        s = s * x
    return s
```
当我们调用power(5)时，相当于调用power(5, 2):
```
>>> power(5)
25
>>> power(5, 2)
25
```
#### 可变参数
```
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
```
定义可变参数在参数前面加了一个\*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：
```
>>> calc(1, 2)
5
>>> calc()
0
```
把list或tuple的元素变成可变参数传进去：
```
>>> nums = [1, 2, 3]
>>> calc(*nums)
14
```
\*nums表示把nums这个list的所有元素作为可变参数传进去。
#### 关键字参数
关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：
```
def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
```
```
>>> person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
>>> person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
```
也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：
```
>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
```
#### 命名关键字参数
如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：
```
def person(name, age, *, city, job):
    print(name, age, city, job)
```
和关键字参数\*\*kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。    
调用方式如下：
```
>>> person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer
```
如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符\*了
```
def person(name, age, *args, city, job):
    print(name, age, args, city, job)
```    
## 高级特性
### 切片
取一个list或tuple的部分元素是非常常见的操作。比如，一个list如下：
```
>>> L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
```
取前3个元素，应该怎么做？
```
>>> L[0:3]
['Michael', 'Sarah', 'Tracy']
```
类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片   
切片操作十分有用。我们先创建一个0-99的数列：
```
>>> L = list(range(100))
>>> L
[0, 1, 2, 3, ..., 99]
```
前10个数：
```
>>> L[:10]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```
后10个数：
```
>>> L[-10:]
[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
```
前10个数，每两个取一个：
```
>>> L[:10:2]
[0, 2, 4, 6, 8]
```
所有数，每5个取一个：
```
>>> L[::5]
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]
```
只写[:]就可以原样复制一个list：
```
>>> L[:]
[0, 1, 2, 3, ..., 99]
```
字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：
```
>>> 'ABCDEFG'[:3]
'ABC'
>>> 'ABCDEFG'[::2]
'ACEG'
```
### 列表生成式
```
>>> [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```
for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方:
```
>>> [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
```
还可以使用两层循环，可以生成全排列：
```
>>> [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
```
列表生成式也可以使用两个变量来生成list：
```
>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> [k + '=' + v for k, v in d.items()]
['y=B', 'x=A', 'z=C']
```
最后把一个list中所有的字符串变成小写：
```
>>> L = ['Hello', 'World', 'IBM', 'Apple']
>>> [s.lower() for s in L]
['hello', 'world', 'ibm', 'apple']
```
## 高阶函数
### map/reduce
ap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
```
>>> def f(x):
...     return x * x
...
>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```
reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算
```
>>> from functools import reduce
>>> def fn(x, y):
...     return x * 10 + y
...
>>> reduce(fn, [1, 3, 5, 7, 9])
13579
```
### filter
和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。   
例如，在一个list中，删掉偶数，只保留奇数，可以这么写：
```
def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
# 结果: [1, 5, 9, 15]
```
### sorted
```
>>> sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]
```
此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：
```
>>> sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
```
实现忽略大小写的排序：
```
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
['about', 'bob', 'Credit', 'Zoo']
```
要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：
```
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
```
## 匿名函数（lambda）
```
>>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```

## 多线程
```
def test(num):
    for i in range(50):
        print(i)
        time.sleep(1)
t1 = threading.Thread(target=test,args=(50,))#注意函数名没有括号
t1.setDaemon(True)#设置守护进程，主进程退出时，子进程退出
t1.start()
t1.is_alive()#判断是否存活
```
